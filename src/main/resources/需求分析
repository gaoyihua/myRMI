关于RMI的简单理解：
RMI（Remote Method Invocation）
1.远程方法调用；
2.设计两个网络端，其核心思想是：一个端可以通过调用另外一个端的方法，实现相关功能；
3.一个端“执行”一个方法，而这个方法实际是在另外一端进行的；
4.两个端都应该有相同的类，自然会有相同的方法；
5.一个端“执行”这个方法其实是通过调用这个类的代理对象的方法，在其中拦截这个方法，
在这个方法中实际上将执行这个方法的参数、类名称和方法名称，通过网络通讯传输给另外一个端，
另外一端得到方法名称、类名称和参数，实际执行那个方法，再将方法执行结果回传给对端；
6.对于RMI客户端（伪执行的一端），仅仅是执行就好，而参数、方法名称、类名称的传递工作不应该自己完成；
7.RMI服务器端是实际执行方法的一端；
8.RMI服务器端可能接收多个RMI客户端有关这个方法的执行请求，每个RMI客户端的执行当然应该是独立的，
应该用线程实现；
9.RMI服务器端在执行了相关方法并回传方法的结果之后，应该断开RMI客户端的连接，即采用短连接；
10.服务器端采用线程池实现。

关于myRMI的模拟实现方案：
基于关于RMI的简单理解从而尝试模拟RMI，大体思路如下：
1.我们的目标：建立RpcServer以及RpcClient后，从RpcClient得到相应接口或者类的代理对象，
执行接口中的方法；
2.这里的执行是通过代理机制，把需要执行的方法和参数通过RpcClientExecutor
发送到RpcServerExecutor中执行；
3.然后再将执行后的结果发回RpcClientExecutor，从而得到执行后的结果，即实现了远程方法调用。

细节问题：
1.考虑代理机制的选择
在产生代理前判断参数是接口还是类，若是接口则采用JDK代理的方式，若是类则采用CGLib代理的方法（现只用JDK代理方式）。
2.服务器端如何通过发送过来的方法和参数执行该方法？
    ①建立一个RpcBeanFactory，用来注册Bean以及获得Bean，其中提供一个Map，以唯一Id为键，
    以RpcBeanDefination为值。RpcBeanDefination由类、对象和方法组成。
    ②注册Bean可以提供多种方式，如扫描注解注册、XML注册、调用专门用来注册的方法注册等等。
    ③注册后，当RpcClientExecutor发过来参数和唯一表示Id时候，RpcServerExecutor通过发过来的
    Id定位相关类、对象方法并且结合发过来的参数 反射 执行该方法，并将结果返回。
3.唯一Id如何确定？
可以通过toString().hashCode()确定唯一beanId（暂定）。

分布式(集群)服务器：  注册中心 =  总控服务器
1.客户端和服务器短连接（RMI）；
2.注册中心与服务器长连接；
4.注册中心与客户机长链接；
5.注册中心核心数据结构是一个Map，键为服务名称，值为一个List，List中包含ip、port、intervalTime
6.注册中心需要对注册过的服务器每隔一段时间进行心跳检测，检测结果写入intervalTime；
7.客户端向注册中心请求服务时， 先发一条请求命令，注册中心将请求服务名称对应的值（ip、port、intervalTime）返回给客户端；
8.客户端根据返回的List中的ip、port、intervalTime列表自行根据策略选择；
9.当客户端向选择的服务器连接时出现问题，那么重新向注册中心请求服务，注册中心返回新的List，客户端根据新的List根据策略选择；
10.服务器向注册中心注册时，先发一条注册命令，再给注册中心发送自己的服务名称以及相应的port；
11.服务器端除了和之前的RPC服务器端类似之外，每个服务器需要有一个服务名称，用于向注册中心注册，也用于客户端根据服务名向注册中心寻找服务器的信息。
   服务器在开启后，需要建立Socket 与 注册中心相连接，
12.客户端除了和之前的RPC客户端类似之外，