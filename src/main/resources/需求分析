关于RMI的简单理解：
RMI（Remote Method Invocation）
1.远程方法调用；
2.设计两个网络端，其核心思想是：一个端可以通过调用另外一个端的方法，实现相关功能；
3.一个端“执行”一个方法，而这个方法实际是在另外一端进行的；
4.两个端都应该有相同的类，自然会有相同的方法；
5.一个端“执行”这个方法其实是通过调用这个类的代理对象的方法，在其中拦截这个方法，
在这个方法中实际上将执行这个方法的参数、类名称和方法名称，通过网络通讯传输给另外一个端，
另外一端得到方法名称、类名称和参数，实际执行那个方法，再将方法执行结果回传给对端；
6.对于RMI客户端（伪执行的一端），仅仅是执行就好，而参数、方法名称、类名称的传递工作不应该自己完成；
7.RMI服务器端是实际执行方法的一端；
8.RMI服务器端可能接收多个RMI客户端有关这个方法的执行请求，每个RMI客户端的执行当然应该是独立的，
应该用线程实现；
9.RMI服务器端在执行了相关方法并回传方法的结果之后，应该断开RMI客户端的连接，即采用短连接；
10.服务器端采用线程池实现。

关于myRMI的模拟实现方案：
基于关于RMI的简单理解从而尝试模拟RMI，大体思路如下：
1.我们的目标：建立RpcServer以及RpcClient后，从RpcClient得到相应接口或者类的代理对象，
执行接口中的方法；
2.这里的执行是通过代理机制，把需要执行的方法和参数通过RpcClientExecutor
发送到RpcServerExecutor中执行；
3.然后再将执行后的结果发回RpcClientExecutor，从而得到执行后的结果，即实现了远程方法调用。

细节问题：
1.考虑代理机制的选择
在产生代理前判断参数是接口还是类，若是接口则采用JDK代理的方式，若是类则采用CGLib代理的方法。
2.服务器端如何通过发送过来的方法和参数执行该方法？
    ①建立一个RpcBeanFactory，用来注册Bean以及获得Bean，其中提供一个Map，以唯一Id为键，
    以RpcBeanDefination为值。RpcBeanDefination由类、对象和方法组成。
    ②注册Bean可以提供多种方式，如扫描注解注册、XML注册、调用专门用来注册的方法注册等等。
    ③注册后，当RpcClientExecutor发过来参数和唯一表示Id时候，RpcServerExecutor通过发过来的
    Id定位相关类、对象方法并且结合发过来的参数 反射 执行该方法，并将结果返回。
3.唯一Id如何确定？
可以通过toString().hashCode()确定唯一beanId。